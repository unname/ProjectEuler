#include <stdlib.h>
#include <iostream>

#include "euler_functions.h"


// Pentagonal numbers are generated by the formula, Pn = n(3n−1) / 2. The first ten pentagonal numbers are :
//
//      1, 5, 12, 22, 35, 51, 70, 92, 117, 145, ...
//
// It can be seen that P4 + P7 = 22 + 70 = 92 = P8. However, their difference, 70 − 22 = 48, is not pentagonal.
//
// Find the pair of pentagonal numbers, Pj and Pk, for which their sum and difference are pentagonal
// and D = |Pk − Pj| is minimised; what is the value of D?

int main(int argc, char **argv)
{
#ifdef _WIN64

    char solution = 0;
    printf("\nGot 2 solutions, shoose necessary:\n\t1) Very Slow Search (pentaginal numbers generation)\n\t2) Slow Search (difference generation)\n");
    solution = getchar();

    printf("\n");

    if (solution == '2')
        goto solution_2;

    // Способ 1 - генерируем числа

    //Number is pentagonal if '(n = 1 + sqrt(24p + 1)) / 6' (получено из '3n^2 - n - 2p = 0') =>
    //
    // 1) 24p + 1 is square 
    // 2) sqrt(24p + 1) = 5 mod 6

    size_t* pentagonals = (size_t* )malloc(sizeof(size_t));
    pentagonals[0] = 1;

    size_t min_pentagonal_dif = -1;

    for (size_t n = 2; ; ++n)
    {
        pentagonals = (size_t*)realloc(pentagonals, n * sizeof(size_t));
        pentagonals[n - 1] = n * (3 * n - 1) / 2;

        size_t min_diffrence = pentagonals[n - 1] - pentagonals[n - 2];

        // min_pentagonal_dif - минимальная найденная разность, удовлетваряющая условию
        // так как дальше разности будут только увеличиваться, то прекращаем поиск
        if (min_diffrence > min_pentagonal_dif)
            break;

        for (size_t k = 0; k < n - 1; k++)
        {
           size_t dif = pentagonals[n - 1] - pentagonals[n - k - 2];

           // Дальше сколько не отнимай новых элементов мы не получим
           // все числа будут лежать в диапазоне от pentagonals[n-2] до  pentagonals[n-1]
           if (dif > pentagonals[n - 2])
               break;

           size_t sum = pentagonals[n - 1] + pentagonals[n - k - 2];

            double sqr = 0;

            if (modf(sqrt(24 * dif + 1), &sqr))
                continue;

            if ((size_t)sqr % 6 != 5)
                continue;

            if (modf(sqrt(24 * sum + 1), &sqr))
                continue;

            if ((size_t)sqr % 6 != 5)
                continue;

            if (dif < min_pentagonal_dif)
                min_pentagonal_dif = dif;

#ifdef _DEBUG
            printf("\nPk  : %Iu\nPj  : %Iu\nPk+j: %Iu\nPk-j: %Iu\n", pentagonals[n - 1], pentagonals[n - k - 2], sum, dif);
#endif
        }
    }

    free(pentagonals);

    printf("\nResult: %Iu\n", min_pentagonal_dif);

    return 0;

solution_2:

    // Способ 2 - генерируем разность

    // optimization based on "Francky" post (on french T_T):
    // 
    // Выведем общую рекурентную формулу из P(i+1) = P(i) + 3i + 1
    // P(i+1) = P(i) + 3i + 1
    // P(i+2) = P(i) + 6i + 5
    // ...
    // P(i+k) = P(i) + 3ki + P(k) 
    //
    // Начинаем с Dmin = D = Pi и ищем D = P(k) - P(j) для всех k = j + d;
    //
    //       P(k) = P(j) + D =>  
    //       
    //       P(j) + P(k) = 2P(j) + D = j(3j - 1) + D 
    //
    //       D = P(k) - P(j) = P(j+d) - P(j) = ... = 3jd + P(d) =>
    //
    //       j = (D - P(d)) / 3d
    // 

    size_t D = 0;
    size_t Dmin = -1;

    for (size_t i = 0;; ++i)
    {
        //Если разница между двумя последними пентагональными элементами больше минимально найденного D,
        // то дальше искать нет смысла, так как она будет только увеличиваться
        if (3 * i + 1 > Dmin)
            goto end;

        D += 3 * i + 1;
        size_t Pd = 0;

        for (size_t d = 1; d < i; ++d)
        {
            Pd += 3 * d - 2;  //перебераем пентоганальные числа до D

            size_t frac = (D - Pd) % (3 * d);

            if (frac == 0)
            {
                //Для целых j, проеверяем что sum = Pj + Pk - pentagonal
                size_t j = (D - Pd) / (3 * d);

                size_t sum = j*(3 * j - 1) + D;
                double sqr = 0;

                if (modf(sqrt(24 * sum + 1), &sqr))
                    continue;

                if ((size_t)sqr % 6 != 5)
                    continue;

#ifdef _DEBUG
                printf("Pk-j: %Iu\n", D);
#endif

                if (Dmin > D)
                    Dmin = D;
            }
        }
    }
    
end:
    printf("\nResult: %Iu", Dmin);

#endif

    return 0;
}