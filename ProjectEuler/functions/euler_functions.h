
// [Task_1] - получить массив(и его размерность) делимых для которых существует хотя бы один из представленных делителей
//
// k1 и k2      - диапазон поиска чисел
// pOut и ulOut - массив найденых чисел и его размерность
// x, ...       - перечень делителей
void get_dividend_by_divisor(size_t k1, size_t k2, size_t *pOut, size_t *ulOut, size_t x, ...);

// [Task_12] - получить массив(и его размерность) делителей для представленного делимого
//
// n            - делимое
// pOut и ulOut - массив делителей и его размерность
void get_divisor_by_dividend(size_t n, size_t *pOut, size_t *ulOut);

// [Task_2] - получить массив(и его размерность) чисел, которые представляют собой последовательность 'Фибоначчи'
//
// n1 и n2      - элементы задающие последовательность
// k            - верхний предел поиска
// pOut и ulOut - массив найденых чисел и его размерность
// start        - функция запускается первый раз (инициализация параметров)
void fib_series(size_t n1, size_t n2, size_t k, size_t *pOut, size_t *ulOut, bool start=false);


// [Task_3] - возведение в степень по модулю
//
// n      - исходное число
// e      - исходная степень
// m      - исходный модуль
// return - остаток деления (результат)
size_t pow_mod(size_t n, size_t e, size_t m);

// [Task_3] - находит представление числа в формате n = 2^s*d+1
//
// n - исходное число
// d - найденный множитель
// s - найденная степень
void expansion_ds(size_t n, size_t *d, size_t *s);

// [Task_3] - проверяет число n на SPRP (сильное вероятно простое число) по основанию a
//
// n           - исходное число
// a           - основание вычислений
// return true - число является a-SPRP 
bool a_sprp(size_t n, size_t a);

// [Task_3] - проверяет число n на отстутсвие простых (маленьких) делителей
//
// n           - исходное число
// k           - количество делителей для проверки
// return true - у числа не найдено делителей из набора
bool test_divisors(size_t n, size_t k);

// [Task_3] - проверяет число n на простату
//
// n           - исходное число
// return true - число простое
bool test_prime(size_t n);

// [Task_4] - проверяет число n на полиндромность
//
// n           - исходное число
// b           - система счисления
// return true - число полиндром
bool test_palindrome(size_t n, size_t b);

// [Task_13] - сложение строковых чисел
//
// n1 и n2 - исходные числа
// sum     - результат сложения
// length  - размер строки результата (с учётом terminate null)
void sum_string(char* n1, char* n2, char* sum, size_t* length);
