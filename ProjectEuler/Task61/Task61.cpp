#include <stdlib.h>
#include <Windows.h>
#include <iostream>

#include "euler_functions.h"

// Triangle, square, pentagonal, hexagonal, heptagonal, and octagonal numbers are all figurate(polygonal) numbers and are generated by the following formulae :
//      Triangle 	P3, n = n(n + 1)/2 	  	1, 3, 6, 10, 15, ...
//      Square 	  	P4, n = n^2 	  	    1, 4, 9, 16, 25, ...
//      Pentagonal 	P5, n = n(3n−1)/2 	    1, 5, 12, 22, 35, ...
//      Hexagonal 	P6, n = n(2n−1) 	  	1, 6, 15, 28, 45, ...
//      Heptagonal 	P7, n = n(5n−3)/2 	  	1, 7, 18, 34, 55, ...
//      Octagonal 	P8, n = n(3n−2) 	  	1, 8, 21, 40, 65, ...
//
// The ordered set of three 4 - digit numbers : 8128, 2882, 8281, has three interesting properties.
//
//      1) The set is cyclic, in that the last two digits of each number is the first two digits of the next number(including the last number with the first).
//      2) Each polygonal type : triangle(P3(127) = 8128), square(P4(91) = 8281), and pentagonal(P5(44) = 2882), is represented by a different number in the set.
//      3) This is the only set of 4-digit numbers with this property.
//
// Find the sum of the only ordered set of six cyclic 4-digit numbers for which each polygonal type :
// triangle, square, pentagonal, hexagonal, heptagonal, and octagonal, is represented by a different number in the set.

size_t zero_bit_count(size_t num, size_t num_length)
{
    size_t count = 0;

    for (size_t i = 0; i < num_length; ++i)
        if (!(num & (1 << i)))
            count++;

    return count;
}

void move_on(__in size_t** vertices_group, __in size_t* vertices_sizes, __in size_t group_size, __in unsigned char group_used, __in size_t previous_vertex, __out size_t** paths[2], __out size_t* paths_size)
{
    size_t groups_cheked = 0;
    
    if (!previous_vertex)
        *paths_size = 0;

    for (size_t current_group = 0; groups_cheked < zero_bit_count(group_used, group_size); ++current_group, current_group %= 6)
    {
        if (group_used & (1 << current_group))
        {
            continue;
        }

        size_t current_vertex = 0;

        for (size_t i = 0; i < vertices_sizes[current_group]; ++i)
        {
            if ((vertices_group[current_group][i] / 100 == previous_vertex && vertices_group[current_group][i] % 100 >= 10) || !previous_vertex)
            {
                if (paths)
                {
                    paths[*paths_size][group_size - zero_bit_count(group_used, group_size)][0] = current_group;
                    paths[*paths_size][group_size - zero_bit_count(group_used, group_size)][1] = vertices_group[current_group][i];
                }

                group_used ^= 1 << current_group;
#ifdef _DEBUG
                printf(" %Iu ->", vertices_group[current_group][i]);
#endif
                current_vertex = vertices_group[current_group][i] % 100;

                if (group_used == pow(2, group_size) - 1)
                {
                    (*paths_size)++;

                    if (paths)
                    {
                        for (size_t i = 0; i < group_size; ++i)
                        {
                            paths[*paths_size][i][0] = paths[*paths_size - 1][i][0];
                            paths[*paths_size][i][1] = paths[*paths_size - 1][i][1];
                        }
                    }

                    return;
                }
                else
                {
                    move_on(vertices_group, vertices_sizes, group_size, group_used, current_vertex, paths, paths_size);

                    group_used ^= 1 << current_group;
#ifdef _DEBUG
                    printf("\n");

                    for (size_t i = 0; i < group_size - zero_bit_count(group_used, group_size); ++i)
                        printf("        ");
#endif
                }
            }
        }

        if (!previous_vertex)
            return;

        groups_cheked++;
    }
}

int main(int argc, char **argv)
{
    const size_t p_min = 3;
    const size_t p_max = 8;

    size_t start_numbers[p_max - p_min + 1] =
    {
        45, 32, 26, 23, 21, 19
    };

    size_t figurate_numbers_sizes[p_max - p_min + 1] = { 0 };

    size_t** figurate_numbers = nullptr;

    for (size_t p = p_min; p <= p_max; ++p)
    {
        figurate_numbers = (size_t**)realloc(figurate_numbers, sizeof(size_t*) * (p - p_min + 1));
        figurate_numbers[p - p_min] = nullptr;

        size_t n_min = start_numbers[p - p_min];
        size_t number = 0;

        for(size_t n = n_min; ; ++n)
        {
            switch (p)
            {
            case 3:
                number = n * (n + 1) / 2;
                break;
            case 4:
                number = n * n;
                break;
            case 5:
                number = n * (3 * n - 1) / 2;
                break;
            case 6:
                number = n * (2 * n - 1);
                break;
            case 7:
                number = n * (5 * n - 3) / 2;
                break;
            case 8:
                number = n * (3 * n - 2);
                break;
            default:
                break;
            }

            if (number > 9999)
            {
                figurate_numbers_sizes[p - p_min] = n - n_min;
                break;
            }

            figurate_numbers[p - p_min] = (size_t*)realloc(figurate_numbers[p - p_min], sizeof(size_t) * (n - n_min + 1));

            figurate_numbers[p - p_min][n - n_min] = number;
        }
    }

    size_t alloc_size = 500;
    size_t path_size = 0;

    size_t*** paths = (size_t***)malloc(sizeof(size_t**) * alloc_size);

    for (size_t i = 0; i < alloc_size; ++i)
    {
        paths[i] = (size_t**)malloc(sizeof(size_t*) * (p_max - p_min + 1));

        for (size_t j = 0; j < p_max - p_min + 1; ++j)
            paths[i][j] = (size_t*)malloc(sizeof(size_t) * 2);
    }

    move_on(figurate_numbers, figurate_numbers_sizes, p_max - p_min + 1, 0, 0, paths, &path_size);

    size_t result = 0;

    printf("\nFounded paths(%Iu):\n", path_size);

    for (size_t i = 0; i < path_size; ++i)
    {
        printf("%Iu)\t", i + 1);

        for (size_t j = 0; j < p_max - p_min + 1; ++j)
        {
            if (paths[i][0][1] / 100 == paths[i][p_max - p_min][1] % 100)
            {
                SetConsoleTextAttribute(GetStdHandle(STD_OUTPUT_HANDLE),
                    FOREGROUND_GREEN | FOREGROUND_INTENSITY);

                printf(" %Iu(P%Iu) ->", paths[i][j][1], paths[i][j][0] + 3);

                SetConsoleTextAttribute(GetStdHandle(STD_OUTPUT_HANDLE),
                    FOREGROUND_GREEN | FOREGROUND_BLUE | FOREGROUND_RED | FOREGROUND_INTENSITY);

                result += paths[i][j][1];
            }
            else
                printf(" %Iu(P%Iu) ->", paths[i][j][1], paths[i][j][0] + 3);
        }

        printf("\n");
    }

    printf("\n\nResult: %Iu\n", result);

    //Освобождаем память
    for (size_t i = 0; i < alloc_size; ++i)
    {
        for (size_t j = 0; j < p_max - p_min + 1; ++j)
            free(paths[i][j]);

        free(paths[i]);
    }

    free(paths);

    for (size_t i = 0; i <= p_max - p_min; ++i)
    {
        free(figurate_numbers[i]);
    }

    free(figurate_numbers);

    return 0;
}